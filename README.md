# Snowflake Sequences for PostgreSQL

For detailed information about using Snowflake sequences and examples, see the pgEdge [documentation](https://docs.pgedge.com/platform/advanced/snowflake#example-converting-an-existing-sequence). 

## Snowflake Sequences - Overview

Snowflake is a PostgreSQL extension that provides an `int8` and `sequence` based unique ID solution to optionally replace the PostgreSQL built-in `bigserial` data type.

Internally snowflake are 64 bit integers represented externally as `bigint` values. The 64 bits are divided into bit fields:

```
bit  63    - unused (sign of int8)
bits 22-62 - timestamp with millisecond precision
bits 10-21 - counter within one millisecond
bits 0-9   - unique PostgreSQL node number set in postgresql.conf
```

* The timestamp is a 41-bit unsigned value representing millisecond
  precision and an epoch of 2023-01-01.

* The counter is a 12-bit unsigned value that increments per ID allocation.
  This provides for 4096 unique IDs per millisecond, or 4 million IDs per
  second.

* The `node number` is a 10-bit unique identifier of the PostgreSQL
  instance inside a global cluster. This value is set with the
  GUC `snowflake.node` in the `postgresql.conf` file.

With this design each snowflake ID is unique within one `sequence`
across multiple PostgreSQL instances in a distributed cluster.

## Installation

**Installing Snowflake with pgEdge binaries**

To use pgEdge binaries to install Snowflake, go to [pgeEdge Github](https://github.com/pgEdge/pgedge) and install the pgEdge CLI:

`./pgedge install pg16 --start : install snowflake`

**Installing Snowflake from source code**

If you're installing from source code, we assume that you're familiar with how to build standard PostgreSQL extensions from source:

```
cd contrib
git clone https://github.com/pgEdge/snowflake-sequences.git
cd snowflake-sequences
USE_PGXS=1 make
USE_PGXS=1 make install
```

After installing the Snowflake extension with the pgEdge binary or from source code, connect to your Postgres database and create the extension with the command:

```
CREATE EXTENSION snowflake;
```

## Configuring Snowflake

The Snowflake extension uses a custom GUC named `snowflake.node` that determines the `node` part of each snowflake generated by the PostgreSQL instance. The permitted values are 1 thru 1023.

This GUC has an invalid default value (on purpose); if not set, the Snowflake extension will throw an exception on a call to `snowflake.nextval()`.  This is intended to prevent you from
accidentally missing this GUC in your `postgresql.conf` file.

If you ever intend to use snowflake in a multi-node, distributed
or replicated setup, it is important to set the GUC to a unique value
for each PostgreSQL instance. There is no protection in place to prevent 
assigning multiple PostgreSQL instances in a multi-master cluster
the same node number.

## Snowflake Functions

After you install and create the Snowflake extension, the following functions are available:

* `snowflake.nextval([sequence regclass])`  
  Generates the next snowflake for the given sequence. If no
  sequence is specified the internal, database-wide sequence
  `snowflake.id_seq` will be used.

  **NOTE:** snowflake are only unique per database, per sequence.
  If you need snowflakes to be unique across all snowflake
  columns within a database, you need to use the built-in sequence
  `snowflake.id_seq`. However, that may interfere with the usage
  of `currval()` of your application logic.

* `snowflake.currval([sequence regclass])`  
  Returns the current value of the given sequence (or the default, internal
  sequence). Like for PostgreSQL sequences this value is undefined until
  the function `snowflake.nextval()` has been called for the sequence in
  the current session.

* `snowflake.get_epoch(snowflake int8)`  
   Returns the timestamp part of the given snowflake as EPOCH
   (seconds since 2023-01-01) as a NUMERIC value with precision of
   three digits. One can use `to_timestamp(snowflake.get_epoch(<value>))`
   to convert this into an actual timestamp.

* `snowflake.get_count(snowflake int8)`  
  Returns the count part of the given snowflake as int4 value.
  This is a unique value within the milliseconds of the snowflake's
  timestamp.

* `snowflake.get_node(snowflake int8)`  
  Returns the setting of GUC `snowflake.node` in postgresql.conf at
  the time, this snowflake was allocated.

* `snowflake.format(snowflake int8)`  
  Returns a `jsonb` object of the given snowflake like:  
  `{"node": 1, "ts": "2023-10-16 17:57:26.361+00", "count": 0}`

* `snowflake.convert_sequence_to_snowflake(p_relid regclass)`  
  Converts an existing sequence into a snowflake. This is done by
  changing any column that uses the given sequence with a
  `DEFAULT pg_catalog.nextval(relid)` expression. The column is
  forced to be type `int8` and the `DEFAULT` expression is
  altered to use the `snowflake.nextval()` function. Then all
  columns that eventually reference such column in a foreign key
  are forced to `int8` as well. Finally the sequence's MAXVALUE
  is adjusted to the current `last_value + 1`, which prevents
  the accidental use of `pg_catalog.nextval()` from user code.

